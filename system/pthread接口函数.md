# **一、线程生命周期及状态**

| **含义**             | **触发条件** | **关键行为**                                         |
| -------------------------- | ------------------ | ---------------------------------------------------------- |
| **内核生命周期状态** | 就绪（Ready）      | 线程已分配除 CPU 外的所有资源，等待内核调度执行。          |
|                            | 运行（Running）    | 线程获得 CPU 时间片，正在执行入口函数中的代码。            |
|                            | 阻塞（Blocked）    | 线程因等待事件（如 I/O、锁、条件变量）暂停执行，释放 CPU。 |
|                            | 终止（Terminated） | 线程执行完毕或被终止，进入资源回收阶段。                   |
| **pthread资源状态**  | 可连接（Joinable） | 线程终止后，资源手动回收，线程 ID、退出状态保留。          |
|                            | 分离（Detached）   | 线程终止后，资源自动释放，但退出状态无法保留。             |

* **内核状态与 pthread 状态的关系** ：内核状态（就绪、运行、阻塞、终止）描述线程的运行生命周期，而 pthread 状态（可连接、分离）描述线程终止后的资源管理方式，两者独立但关联（如终止的线程需根据 pthread 状态决定资源回收方式）。
* **阻塞状态的细分** ：阻塞状态可进一步根据等待事件类型（如 I/O 阻塞、锁阻塞、条件变量阻塞）区分，但内核视角统一归为 "阻塞"。
* **终止状态的回收** ：内核负责回收线程的 CPU、寄存器等资源，pthread 库负责回收线程 ID、栈空间等用户态资源（依赖分离状态）。

# **二、线程管理模块**

**模块说明** ：负责线程的生命周期管理（创建、终止、等待、状态控制），是多线程程序的基础，解决 "如何启动、停止和协调线程" 的问题。

| **函数原型**                                                                                            | **解释说明**                                                                                                                                                                                                                | **使用场景**                                                                         |
| ------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| `int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*start_routine)(void*), void *arg);` | 创建新线程，指定入口函数和参数。<br />- `tid`：输出线程 ID<br />- `attr`：线程属性（如栈大小，NULL为默认）<br />- `start_routine`：线程入口函数<br />- `arg`：传递给入口函数的参数<br />- `return`：0 成功，非 0 错误码 | 启动后台任务（如网络请求、数据计算），需并发执行多个独立任务时（如多线程下载）。           |
| `void pthread_exit(void *retval);`                                                                          | 终止当前线程，返回退出状态，线程执行完毕或异常时调用。<br />- `retval`：线程返回值（可被pthread_join获取）                                                                                                                      | 线程任务完成后主动退出（如计算任务结束），或因错误提前终止（如读取文件失败）。             |
| `int pthread_join(pthread_t tid, void **retval);`                                                           | 阻塞等待指定线程终止，并回收其资源。<br />- `tid`：目标线程 ID<br />- `retval`：输出线程返回值<br />- `return`：0 成功，非 0 错误码                                                                                         | 主线程需要等待子线程结果（如多线程计算后汇总），确保资源正确回收（如等待所有子任务完成）。 |
| `int pthread_detach(pthread_t tid);`                                                                        | 分离线程（终止后自动回收资源，无需 pthread_join）。<br />- `return`：0 成功，非 0 错误码                                                                                                                                        | 无需关心线程返回值（如后台日志线程、心跳检测线程），避免资源泄漏。                         |
| `pthread_t pthread_self(void);`                                                                             | 获取当前线程的 ID（类型为 pthread_t）。                                                                                                                                                                                           | 在线程内部标记身份（如日志记录时标注线程 ID，或错误跟踪时区分线程）。                      |
| `int pthread_cancel(pthread_t tid);`                                                                        | 一个线程向其它线程发送取消请求（线程需启用取消状态）。<br />- `return`：0 成功，非 0 错误码                                                                                                                                     | 强制终止超时或冗余的线程（如长时间未响应的网络请求、用户主动取消的任务）。                 |

---

# **三、互斥锁模块**

**模块说明** ：保护临界区（共享资源的访问代码），确保同一时间仅一个线程访问，解决 "多线程并发修改共享资源导致的数据竞争" 问题。

| **函数原型**                                                                   | **解释说明**                                                                                                                           | **使用场景**                                                                 |
| ------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| `int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);` | 动态初始化互斥锁。<br />- `mutex`：互斥锁对象指针<br />- `attr`：互斥锁属性（如类型，NULL为默认）<br />- `return`：0 成功，非 0 错误码 | 需要根据运行时条件创建互斥锁（如动态分配的共享资源，如链表、哈希表）。             |
| `pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;`                               | 静态初始化互斥锁（等价于 `pthread_mutex_init(mutex, NULL)`）。                                                                             | 互斥锁生命周期与程序一致（如全局变量的锁，如全局计数器、配置参数）。               |
| `int pthread_mutex_lock(pthread_mutex_t *mutex);`                                  | 加锁（阻塞：若锁被占用，线程进入阻塞态）。                                                                                                   | 保护临界区（如共享变量修改、文件写入），确保独占访问（如多线程更新同一个计数器）。 |
| `int pthread_mutex_trylock(pthread_mutex_t *mutex);`                               | 尝试加锁（非阻塞：若锁被占用，返回 `EBUSY`）。                                                                                             | 非强制需要锁时（如尝试获取锁失败后执行其他逻辑，如降级为本地缓存）。               |
| `int pthread_mutex_unlock(pthread_mutex_t *mutex);`                                | 解锁（释放锁，唤醒等待线程）。                                                                                                               | 临界区操作完成后释放锁，允许其他线程访问（如修改完共享变量后释放锁）。             |
| `int pthread_mutex_destroy(pthread_mutex_t *mutex);`                               | 销毁互斥锁（需确保无线程持有锁）。<br />- `return`：0 成功，非 0 错误码                                                                    | 互斥锁不再使用时释放资源（如动态创建的锁，如临时共享资源不再需要时）。             |

---

# **四、条件变量模块**

**模块说明** ：协调线程协作，允许线程等待特定条件满足（需配合互斥锁使用），解决 "线程间需要等待事件触发" 的问题（如生产者 - 消费者模型）。

| **函数原型**                                                                                            | **解释说明**                                                                                                                                                                                                                                                                              | **使用场景**                                                               |
| ------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| `int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);`                              | 动态初始化条件变量。<br />- `cond`：条件变量对象指针<br />- `attr`：条件变量属性（如进程共享，NULL为默认）<br />- `return`：0 成功，非 0 错误码                                                                                                                                           | 需要动态创建条件变量（如线程池中的任务队列通知，任务队列为空时消费者等待）。     |
| `pthread_cond_t cond = PTHREAD_COND_INITIALIZER;`                                                           | 静态初始化条件变量（等价于 `pthread_cond_init(cond, NULL)`）。                                                                                                                                                                                                                                | 条件变量生命周期与程序一致（如全局事件通知，如系统资源就绪后通知所有等待线程）。 |
| `int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);`                                      | 等待条件变量（原子操作：释放锁 → 阻塞 → 唤醒后重新加锁）。必须在持有 `mutex` 时调用                                                                                                                                                                                                         | 线程需要等待特定条件满足（如消费者等待队列非空、生产者等待缓冲区有空位）。       |
| `int pthread_cond_signal(pthread_cond_t *cond);`                                                            | 唤醒一个等待条件变量的线程（若有多个，选择一个）。                                                                                                                                                                                                                                              | 条件满足时通知单个等待线程（如生产者生产数据后唤醒一个消费者处理数据）。         |
| `int pthread_cond_broadcast(pthread_cond_t *cond);`                                                         | 唤醒所有等待条件变量的线程。                                                                                                                                                                                                                                                                    | 条件满足时通知所有等待线程（如系统资源释放后唤醒所有等待的工作线程）。           |
| `int pthread_cond_destroy(pthread_cond_t *cond);`                                                           | 销毁条件变量（需确保无线程等待）。<br />- `return`：0 成功，非 0 错误码                                                                                                                                                                                                                       | 条件变量不再使用时释放资源（如动态创建的条件变量，如临时任务队列不再需要时）。   |
| `int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);` | 带超时的条件变量等待<br />- `cond`: 等待的条件变量<br />- `mutex `: 与条件变量关联的互斥锁<br />- `abstime `: 绝对超时时间（相对于 1970-01-01 00:00:00 的时间点），非相对等待时长<br />- `return`: 若被唤醒（条件满足），函数返回 0（成功）; 若超时，函数返回 ETIMEDOUT（超时错误码）。 | 用于在线程间同步时，让线程在指定时间内等待条件满足，避免无限阻塞。               |

---

# **五、读写锁模块**

**模块说明** ：支持 “共享读、独占写”，优化读多写少场景的并发效率，解决 “读操作远多于写操作时互斥锁效率低下” 的问题。

| **函数原型**                                        | **解释说明**                                                        | **使用场景**                                                                 |
| --------------------------------------------------------- | ------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| `int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);`  | 加读锁（阻塞：若写锁被占用，线程等待）。允许多线程共享读锁                | 读多写少场景（如配置参数读取、缓存查询），提升读并发性能（如多线程读取配置文件）。 |
| `int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);`  | 加写锁（阻塞：若读锁或写锁被占用，线程等待）。仅允许单线程写锁            | 写操作（如更新配置参数、修改缓存）时需要独占访问（如定时更新配置文件内容）。       |
| `int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);`  | 解锁（读锁或写锁）。                                                      | 读 / 写操作完成后释放锁，允许其他线程访问（如读取或修改完配置后释放锁）。          |
| `int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);` | 销毁读写锁（需确保无线程持有锁）。<br />- `return`：0 成功，非 0 错误码 | 读写锁不再使用时释放资源（如动态创建的读写锁，如临时缓存不再需要时）。             |

---

# **六、线程局部存储模块**

**模块说明** ：为每个线程提供独立的存储区域，避免共享变量的同步开销，解决 "线程需要私有数据" 的问题（如线程私有缓存、日志句柄）。

| **函数原型**                                                         | **解释说明**                                                                                                                                     | **使用场景**                                                         |
| -------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------- |
| `int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));` | 创建线程局部存储的键。<br />- `key`：输出键<br />- `destructor`：线程终止时释放存储的回调（`NULL`表示无）<br />- `return`：0 成功，非 0 错误码 | 需要为每个线程分配独立数据（如线程私有日志缓冲区、数据库连接句柄）。       |
| `int pthread_setspecific(pthread_key_t key, const void *value);`         | 为当前线程的键设置值（value 为线程私有数据指针）。<br />- `return`：0 成功，非 0 错误码                                                              | 在线程内部存储私有数据（如用户会话信息、临时计算结果）。                   |
| `void *pthread_getspecific(pthread_key_t key);`                          | 获取当前线程的键对应的值（无值返回 NULL）。                                                                                                            | 在线程内部读取之前存储的私有数据（如恢复会话状态、获取缓存）。             |
| `int pthread_key_delete(pthread_key_t key);`                             | 删除键（不自动释放线程存储，需手动清理）。<br />- `return`：0 成功，非 0 错误码                                                                      | 线程局部存储不再使用时释放键资源（如动态创建的键，如临时任务不再需要时）。 |

---

# **七、线程属性模块**

**模块说明** ：配置线程的高级属性（如栈大小、分离状态），满足不同场景的资源需求，解决 "线程需要定制化资源" 的问题（如大栈空间、自动回收）。

| **函数原型**                                                          | **解释说明**                                                                                                         | **使用场景**                                                                     |
| --------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| `int pthread_attr_init(pthread_attr_t *attr);`                            | 初始化线程属性对象（默认值：非分离、默认栈大小等）。<br />- `return`：0 成功，非 0 错误码                                | 需要自定义线程属性（如调整栈大小、设置分离状态）时初始化属性对象（如创建大栈线程前）。 |
| `int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);` | 设置线程分离状态（PTHREAD_CREATE_DETACHED 分离或 PTHREAD_CREATE_JOINABLE 可连接）。<br />- `return`：0 成功，非 0 错误码 | 需要控制线程是否自动回收资源（如后台线程设为分离态，避免 pthread_join）。              |
| `int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);`  | 设置线程栈大小（需大于 PTHREAD_STACK_MIN）。<br />- `return`：0 成功，非 0 错误码                                        | 线程需要较大栈空间（如递归深度大的任务、大数组局部变量）。                             |
| `int pthread_attr_destroy(pthread_attr_t *attr);`                         | 销毁线程属性对象（释放资源）。<br />- `return`：0 成功，非 0 错误码                                                      | 线程属性对象不再使用时释放资源（如动态创建的属性对象，如临时线程创建完成后）。         |

---

# **八、其他辅助模块**

**模块说明** ：提供线程安全的初始化、一次性执行等辅助功能，解决 "多线程环境下的特殊需求"（如全局资源初始化）。

| **函数原型**                                                              | **解释说明**                                                                                                                             | **使用场景**                                                                       |
| ------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| `int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));` | 确保初始化函数 init_routine 仅被调用一次（线程安全）。<br />- `once_control`初始化为PTHREAD_ONCE_INIT<br />- `return`：0 成功，非 0 错误码 | 全局资源初始化（如加载配置、初始化单例对象），避免多线程重复初始化（如日志系统初始化）。 |
