exec 用于替换当前进程为新程序的系统调用族。其核心作用是：用指定的新程序（二进制文件或脚本）覆盖当前进程的内存空间（代码、数据、堆、栈等），并从新程序的入口点开始执行。

# exec与fork的关系

fork用于创建子进程（复制原进程），而 exec用于在现有进程或子进程中加载并执行新程序。二者常配合使用：父进程通过 fork 创建子进程后，子进程调用 exec 加载新程序（原父进程继续运行，子进程被新程序替代）。

# exec系列函数的核心变体

exec家族包含多个函数（如 `execl`、`execv`、`execvp` 等），区别主要在于参数传递方式和查找程序路径的规则 ：

| 函数名     | 参数形式                   | 路径查找规则                           | 典型用途                  |
| ---------- | -------------------------- | -------------------------------------- | ------------------------- |
| `execl`  | 可变参数列表（`l`=list） | 完整路径（需显式指定）                 | 已知程序绝对路径时使用    |
| `execv`  | 数组参数（`v`=vector）   | 完整路径（需显式指定）                 | 参数较多时用数组传递      |
| `execvp` | 数组参数（`v`=vector）   | 从 `PATH` 环境变量查找（`p`=path） | 执行系统命令（如 `ls`） |

# exec关键特性

1. **内存覆盖** ：执行exec() 后，原进程的代码段、数据段、堆、栈等内存空间被新程序完全替换，原进程的后续代码不会继续执行 （除非exec()调用失败）。
2. **文件描述符继承** ：原进程打开的文件描述符默认会被新程序保留（除非设置了`FD_CLOEXEC` 标志）。
3. **执行失败处理** ：exec() 成功时无返回值（因为原进程已被替换）；失败时返回`-1`，原进程继续执行后续代码（需通过`perror` 等函数处理错误）。

# exec示例代码

```c
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>

int main()
{
	pid_t pid = fork();
	if (pid == 0) {					   // 子进程
		execl("/bin/sleep", "sleep", "300", NULL); // 使用/bin/sleep替换当前进程
	} else if (pid > 0) {				   // 父进程
		waitpid(pid, NULL, 0);
		printf("子进程执行完成\n");
	}
	return 0;
}
```
